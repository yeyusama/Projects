var PENDING = "pending" // promise实例的初始化状态
var RESOLVED = "resolved" // promise实例的成功状态
var REJECTED = "rejected" // promise实例的失败状态
//es6和es5的差别是什么，class类就是一个es6的函数，将代码组合好全部放入class里面
//class就是相当于定义了一个函数，函数里面有自己的实例化函数，只有自己的实例对象可以调用
//静态函数自己和实例化对象都可以调用

class MyPromise {
    constructor(exec){
        var that = this; //劫持this
        this.state = PENDING;
        this.value = undefined;
        this.callBacks = [];

        function resolve(value) {

            if(that.state !== PENDING){
                return
            }

            that.state = RESOLVED
            that.value = value
            // 等promise状态确定时 将callBacks中的回调塞到异步队列中
            that.callBacks.forEach(function (item) {
                setTimeout(function () {
                    item.onResolve()
                },0)
            })
        }
        function reject(errMsg) {

            if(that.state !== PENDING){
                return
            }

            that.state = REJECTED
            that.value = errMsg
            // 等promise状态确定时 将callBacks中的回调塞到异步队列中
            that.callBacks.forEach(function (item) {
                setTimeout(function () {
                    item.onReject()
                },0)
            })
        }

        try {
            exec(resolve,reject)
        }catch (e) {
            reject(e.message)
        }

        return this;
    }
    //带有prototype的都是class的实例化函数
    //普通的函数就是
    //class中只有实例化对象可以调用实例化函数
    then(onResolve,onReject){
        var that = this;
        return new MyPromise(function (resolve,reject) {

            if(typeof onResolve !== "function"){
                onResolve = function (val) {
                    return val
                }
            }

            if(typeof onReject !== "function"){
                onReject = function (errMsg) {
                    throw new Error(errMsg)
                }
            }


            // 拿到onResolve 或 onReject的返回结果  根据这个返回结果来确定then返回的promise的状态
            function handleResult(callBack) {
                try{
                    // 实现了值的传递
                    var result = callBack(that.value);
                    if(result instanceof MyPromise){
                        result.then(function (val) {
                            resolve(val)
                        },function (errMsg) {
                            reject(errMsg)
                        })
                        //...
                    }else{
                        resolve(result)
                    }
                }catch (e) {
                    reject(e.message)
                }
            }

            if(that.state === PENDING){
                // 当前promise实例在调用then方法的时候 状态没有确定
                that.callBacks.push({
                    onResolve:function () {
                        handleResult(onResolve)
                    },
                    onReject:function () {
                        handleResult(onReject)
                    }
                })
            }else if(that.state === RESOLVED){
                // 当前promise实例在调用then方法的时候 状态已经确定为成功
                setTimeout(function () {
                    handleResult(onResolve)
                    // onResolve()
                },0)
            }else if(that.state === REJECTED){
                // 当前promise实例在调用then方法的时候 状态已经确定为失败
                setTimeout(function () {
                    handleResult(onReject)
                    // onReject()
                },0)
            }
        })
    }
    catch(onReject){
        return this.then(null,onReject)
    }
    static reject(errMsg){
        return new MyPromise(function (resolve,reject) {
            reject(errMsg)
        })
    }
    static resolve(val){
        return new MyPromise(function (resolve,reject) {
            if(val instanceof MyPromise){
                /* val.then(function (successVal) {
                     resolve(successVal)
                 },function (errMsg) {
                     reject(errMsg)
                 })*/
                val.then(resolve,reject)
            }else{
                resolve(val)
            }
        })
    }
    static race(promiseArr){
        return new MyPromise(function (resolve,reject) {
            promiseArr.forEach(function (promise) {
                promise.then(function (val) {
                    resolve(val)
                },function (errMsg) {
                    reject(errMsg)
                })
            })
        })
    }
    static all(promiseArr){
        return new MyPromise(function (resolve,reject) {
            var flag = 0;
            var resultArr =[];
            promiseArr.forEach(function (promise,index) {
                promise.then(function (val) {
                    flag++;
                    resultArr[index] = val;
                    if(promiseArr.length === flag){
                        resolve(resultArr)
                    }
                },function (errMsg) {
                    reject(errMsg)
                })
            })
        })
    }
}

